'''in this script, we compare two ways of generating the solutions of an OU process (ie linear SDE)
driven by white noise convolved with a Gaussian kernel (ie coloured noise)
For such a given two-dimensional process, we compare the sample paths of:
1) The Euler integration method, where the sample paths of the noise process will have been generated using the method of generalised coordinates
2) The full generalised coordinates method used to integrate the stochastic differential equation
'''

import numpy as np
import sympy as sp
from Routines import Taylor_series
from Routines import sampling_generalised_noise
import matplotlib.pyplot as plt
from integration import Euler
#from scipy.linalg import expm


'''Part 0: specifying the OU process'''

'Part 0a: Specifying the drift matrix of the OU process'''

dim =1 #State space dimension

#alpha= 1 #Scaling of solenoidal flow

#Q = alpha * np.array([0, 1, -1, 0]).reshape([dim, dim]) #solenoidal flow matrix

#B= np.eye(dim)+Q #negative drift matrix of OU process for a steady state distribution N(0,I)

B=-np.ones(1)

def flow(x):
    return B @ x



'Part 0b: Specifying the kernel of the noise process'

h = sp.symbols('h')
beta=1

K = sp.sqrt(beta / (2 * sp.pi)) * sp.exp(-beta / 2 * h * h) # NORMALISED Gaussian kernel given as a symbolic expression



'''Part 1: Specifying parameters of integration'''

N= 30 #number of sample paths

x0= 10*np.ones([dim, N]) #initial condition


timesteps=10**3
Time = np.linspace(0,100,timesteps) #time grid over which we integrate

'Part 1a: getting the serial derivatives of the noise process'

order = 10

at=0

tilde_w0= sampling_generalised_noise.sample_gen_noise(K=K,wrt=h,at=at,order= order,N=N) #Generalised fluctuations at time zero


#Point of info: determinant of generalised covariance as a function of order grows faster than exponentially
order_simul=10 #order for this simulation
tilde_Sigma= sampling_generalised_noise.gen_covariance(K=K,wrt=h,at=at,order= order_simul)
dets = []
for i in range(1, order_simul+1):
    dets.append(np.linalg.det(tilde_Sigma[:i,:i]))
plt.figure(0)
plt.clf()
plt.plot(range(1, order_simul+1), dets)
plt.yscale('log')
plt.suptitle(r'Determinant of $\tilde \Sigma$ w.r.t. number of generalised orders', fontsize=16)



'''Part 2: Generalised coordinates integration'''
#Input: flow function

'Part 2a: Getting serial derivatives of solution for each sample at time at '

tilde_x0= np.empty([dim, order+1, N])
tilde_x0[:,0,:]=x0

for i in range(order):
    tilde_x0[:,i+1,:]=flow(tilde_x0[:,i,:]) + tilde_w0[i,:]


'Part 2b: Generating sample paths of solution'


xt= np.empty([dim, Time.size, N])

for i in range(N):
    xt[:,:, i] = Taylor_series.taylor_eval(derivs=tilde_x0[0,:,i] ,at=0,Time=Time) #redo dim




'''Part 3: Euler integration'''


'Part 3a: getting the sample paths of the noise process'

wt = np.empty([dim, Time.size, N])  # white noise generated by generalised coordinates
for i in range(N):
    wt[:,:, i] = Taylor_series.taylor_eval(derivs=tilde_w0[:, i], at=0,Time=Time)


'Part 3b: getting the solution by Euler integration'


xt_Euler= Euler.Euler_integration(x0=x0,f=flow, wt=wt,Time=Time)




'''Part 4: Path of least action'''


'Part 4a: getting the path of least action, ie path in the absence of noise'
xt_least=np.empty([dim,Time.size,N])
for t in range(timesteps):
    xt_least[:,t,:]=np.exp(B*Time[t])@x0

#xt_least= Euler.Euler_integration(x0=x0,f=flow, wt=np.zeros(wt.shape),Time=Time)


'''Part 5: Plots'''

'Part 5a: 1D plot of gen coord method'

plot_indices=range(min(30,timesteps))
lw=0.5

plt.figure(1)
plt.clf()
plt.plot(Time[plot_indices], xt_least[0,plot_indices,0], color='gray',linestyle=':')
for n in range(N):  # Iterating over samples of white noise
    plt.plot(Time[plot_indices], xt[0,plot_indices, n], linewidth=lw,alpha=0.5)
# plt.plot(gammas, epr_gamma_alter, c='black', linestyle='dashed')
# plt.legend()
plt.xlabel(r'Time $t$')
plt.ylabel(r'$x_t$')
plt.suptitle('Coloured OU process', fontsize=16)
plt.title(f'Generalised coordinates, order={order+1}', fontsize=14)
plt.ylim(top=11,bottom=-5)
# plt.savefig(f"OU2d_EPR_func_gamma.png", dpi=100)


'Part 5b: 1D plot of Euler method'

plt.figure(2)
plt.clf()
plt.plot(Time[plot_indices], xt_least[0,plot_indices,0], color='gray',linestyle=':')
for n in range(N):  # Iterating over samples of white noise
    plt.plot(Time[plot_indices], xt_Euler[0,plot_indices, n], linewidth=lw,alpha=0.5)
plt.xlabel(r'Time $t$')
plt.ylabel(r'$x_t$')
plt.suptitle('Coloured OU process', fontsize=16)
plt.title(f'Euler method, order={order+1}', fontsize=14)
plt.ylim(top=11,bottom=-5)
# plt.savefig(f"OU2d_EPR_func_gamma.png", dpi=100)

'Part 5c: 1D plot of convolved white noise sample paths'

plt.figure(3)
plt.clf()
wt_least =np.zeros(Time.size)
plt.plot(Time[plot_indices], wt_least[plot_indices], color='gray',linestyle=':')
for n in range(N):  # Iterating over samples of white noise
    plt.plot(Time[plot_indices], wt[0,plot_indices, n], linewidth=lw,alpha=0.5)
plt.xlabel(r'Time $t$')
plt.ylabel(r'$w_t$')
plt.suptitle('Coloured noise', fontsize=16)#
plt.title(f'Generalised coordinates, order={order}', fontsize=14)
plt.ylim(top=3,bottom=-3)
# plt.savefig(f"OU2d_EPR_func_gamma.png", dpi=100)




